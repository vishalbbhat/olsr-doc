<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OONF OLSRv2: include/oonf/libcommon/avl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OONF OLSRv2
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ebab758ab1419a0154486d2d5e2b8f15.html">oonf</a></li><li class="navelem"><a class="el" href="dir_1abae6dfe228ecc70f22d7a547e0fb57.html">libcommon</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">avl.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="oonf_8h_source.html">oonf/oonf.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="container__of_8h_source.html">oonf/libcommon/container_of.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="list_8h_source.html">oonf/libcommon/list.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for avl.h:</div>
<div class="dyncontent">
<div class="center"><img src="avl_8h__incl.png" border="0" usemap="#include_2oonf_2libcommon_2avl_8h" alt=""/></div>
<map name="include_2oonf_2libcommon_2avl_8h" id="include_2oonf_2libcommon_2avl_8h">
<area shape="rect" id="node3" href="oonf_8h.html" title="oonf/oonf.h" alt="" coords="301,244,387,271"/>
<area shape="rect" id="node5" href="container__of_8h.html" title="oonf/libcommon/container_of.h" alt="" coords="25,169,225,196"/>
<area shape="rect" id="node6" href="list_8h.html" title="oonf/libcommon/list.h" alt="" coords="172,95,319,121"/>
</map>
</div>
</div>
<p><a href="avl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavl__node.html">avl_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavl__tree.html">avl_tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ade9b574d813366c603812eb967213c75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ade9b574d813366c603812eb967213c75">AVL_STATIC_INIT</a>(avl,  avl_comp,  dups)</td></tr>
<tr class="separator:ade9b574d813366c603812eb967213c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bfca92c030dd0ea5548f23de5fc07e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a65bfca92c030dd0ea5548f23de5fc07e">avl_find_element</a>(tree,  key,  element,  node_element)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#adbe2b7a707fb28492e3bf3530e907007">avl_find</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td></tr>
<tr class="separator:a65bfca92c030dd0ea5548f23de5fc07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad192b6c3845ad3a505b7bcb0d63dfeec"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ad192b6c3845ad3a505b7bcb0d63dfeec">avl_find_le_element</a>(tree,  key,  element,  node_element)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#aaa898c124264452198484c6d9554d41a">avl_find_lessequal</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td></tr>
<tr class="separator:ad192b6c3845ad3a505b7bcb0d63dfeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd583d925c5b1aa89caf22ed6148cf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aabd583d925c5b1aa89caf22ed6148cf2">avl_find_ge_element</a>(tree,  key,  element,  node_element)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#a006b2043dafbfa776319ab77d8437989">avl_find_greaterequal</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td></tr>
<tr class="separator:aabd583d925c5b1aa89caf22ed6148cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4277656aa8eae4fd79338987cfd26c97"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree,  element,  node_member)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((tree)-&gt;list_head.next, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td></tr>
<tr class="separator:a4277656aa8eae4fd79338987cfd26c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e4b75df996ec04ebdcddf6c936e97d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aa1e4b75df996ec04ebdcddf6c936e97d">avl_first_element_safe</a>(tree,  element,  node_member)&#160;&#160;&#160;(avl_is_empty(tree) ? NULL : <a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member))</td></tr>
<tr class="separator:aa1e4b75df996ec04ebdcddf6c936e97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a99bff7b106865d925fdc7461cdaad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree,  element,  node_member)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((tree)-&gt;list_head.prev, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td></tr>
<tr class="separator:a99a99bff7b106865d925fdc7461cdaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7118685741f22a5cab57c8432eec1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aa3b7118685741f22a5cab57c8432eec1">avl_last_element_safe</a>(tree,  element,  node_member)&#160;&#160;&#160;(avl_is_empty(tree) ? NULL : <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member))</td></tr>
<tr class="separator:aa3b7118685741f22a5cab57c8432eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44808c5fc055437c429a05a9b0a06c64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element,  node_member)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((&amp;(element)-&gt;node_member.list)-&gt;next, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td></tr>
<tr class="separator:a44808c5fc055437c429a05a9b0a06c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9359a8fcb7171306d829d2ef0b9ce87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ac9359a8fcb7171306d829d2ef0b9ce87">avl_next_element_safe</a>(tree,  element,  node_member)&#160;&#160;&#160;((element) == NULL || avl_is_last(tree, &amp;(element)-&gt;node_member) ? NULL : <a class="el" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member))</td></tr>
<tr class="separator:ac9359a8fcb7171306d829d2ef0b9ce87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026fe6e9f4d8435a20d49c98e05296ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(element,  node_member)&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((&amp;(element)-&gt;node_member.list)-&gt;prev, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td></tr>
<tr class="separator:a026fe6e9f4d8435a20d49c98e05296ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e01666c8f5bf8bd7b115ea69e96cdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a41e01666c8f5bf8bd7b115ea69e96cdc">avl_prev_element_safe</a>(tree,  element,  node_member)&#160;&#160;&#160;((element) == NULL || avl_is_first(tree, &amp;(element)-&gt;node_member) ? NULL : <a class="el" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(element, node_member))</td></tr>
<tr class="separator:a41e01666c8f5bf8bd7b115ea69e96cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d15c4acb3bebd05c7f55835f761a02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(first,  last,  element,  node_member)</td></tr>
<tr class="separator:a03d15c4acb3bebd05c7f55835f761a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79d2dca3164c0d9d147290f81cc0a1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(first,  last,  element,  node_member)</td></tr>
<tr class="separator:ab79d2dca3164c0d9d147290f81cc0a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fce1e55fe672174caa3053a460ae56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a78fce1e55fe672174caa3053a460ae56">avl_for_each_element</a>(tree,  element,  node_member)</td></tr>
<tr class="separator:a78fce1e55fe672174caa3053a460ae56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708d9a638840e5762c4fffad19749d40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a708d9a638840e5762c4fffad19749d40">avl_for_each_element_reverse</a>(tree,  element,  node_member)</td></tr>
<tr class="separator:a708d9a638840e5762c4fffad19749d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57e527be83dae1b21136e7ba479b8ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ae57e527be83dae1b21136e7ba479b8ce">avl_for_element_to_last</a>(tree,  first,  element,  node_member)&#160;&#160;&#160;<a class="el" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(first, <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</td></tr>
<tr class="separator:ae57e527be83dae1b21136e7ba479b8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1917526ba24d06dc9bcc54979dc03d9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a1917526ba24d06dc9bcc54979dc03d9c">avl_for_element_to_last_reverse</a>(tree,  first,  element,  node_member)&#160;&#160;&#160;<a class="el" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(first, <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</td></tr>
<tr class="separator:a1917526ba24d06dc9bcc54979dc03d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159c839ce250ac3aaf7f7f1109c062d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a159c839ce250ac3aaf7f7f1109c062d5">avl_for_first_to_element</a>(tree,  last,  element,  node_member)&#160;&#160;&#160;<a class="el" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(<a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), last, element, node_member)</td></tr>
<tr class="separator:a159c839ce250ac3aaf7f7f1109c062d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9b3eeac0e8ccf932b344c0fda83a56"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a4e9b3eeac0e8ccf932b344c0fda83a56">avl_for_first_to_element_reverse</a>(tree,  last,  element,  node_member)&#160;&#160;&#160;<a class="el" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(<a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), last, element, node_member)</td></tr>
<tr class="separator:a4e9b3eeac0e8ccf932b344c0fda83a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13b5a4ff4e153f6c9e6d2bb5a791ef0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#af13b5a4ff4e153f6c9e6d2bb5a791ef0">avl_for_each_elements_with_key</a>(tree,  element,  node_member,  start,  key)</td></tr>
<tr class="separator:af13b5a4ff4e153f6c9e6d2bb5a791ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947645c2b3a446f3a3fe51b5d3a5ae9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a947645c2b3a446f3a3fe51b5d3a5ae9d">avl_for_element_range_safe</a>(first_element,  last_element,  element,  node_member,  ptr)</td></tr>
<tr class="separator:a947645c2b3a446f3a3fe51b5d3a5ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753153e0b7e41586afc8bdc5dae9638a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a753153e0b7e41586afc8bdc5dae9638a">avl_for_element_range_reverse_safe</a>(first_element,  last_element,  element,  node_member,  ptr)</td></tr>
<tr class="separator:a753153e0b7e41586afc8bdc5dae9638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23455256f763fb1e8034c6d9537a0ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ab23455256f763fb1e8034c6d9537a0ed">avl_for_each_element_safe</a>(tree,  element,  node_member,  ptr)</td></tr>
<tr class="separator:ab23455256f763fb1e8034c6d9537a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8268f3218ef99abb26a7e5fe131ff7b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a8268f3218ef99abb26a7e5fe131ff7b5">avl_for_each_element_reverse_safe</a>(tree,  element,  node_member,  ptr)</td></tr>
<tr class="separator:a8268f3218ef99abb26a7e5fe131ff7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5bd4e29fca7922b4d0a48bca7f6c1e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a6a5bd4e29fca7922b4d0a48bca7f6c1e">avl_for_each_elements_with_key_safe</a>(tree,  element,  node_member,  start,  iterator,  key)</td></tr>
<tr class="separator:a6a5bd4e29fca7922b4d0a48bca7f6c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b3ca3843e7a4bb3bc80858f53c2ad5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#af8b3ca3843e7a4bb3bc80858f53c2ad5">avl_remove_all_elements</a>(tree,  element,  node_member,  ptr)</td></tr>
<tr class="separator:af8b3ca3843e7a4bb3bc80858f53c2ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34c5f9b73909d1b4abadb947a0f898dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a34c5f9b73909d1b4abadb947a0f898dd">avl_init</a> (struct <a class="el" href="structavl__tree.html">avl_tree</a> *, int(*comp)(const void *k1, const void *k2), bool)</td></tr>
<tr class="separator:a34c5f9b73909d1b4abadb947a0f898dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe2b7a707fb28492e3bf3530e907007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#adbe2b7a707fb28492e3bf3530e907007">avl_find</a> (const struct <a class="el" href="structavl__tree.html">avl_tree</a> *, const void *)</td></tr>
<tr class="separator:adbe2b7a707fb28492e3bf3530e907007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006b2043dafbfa776319ab77d8437989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a006b2043dafbfa776319ab77d8437989">avl_find_greaterequal</a> (const struct <a class="el" href="structavl__tree.html">avl_tree</a> *tree, const void *key)</td></tr>
<tr class="separator:a006b2043dafbfa776319ab77d8437989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa898c124264452198484c6d9554d41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#aaa898c124264452198484c6d9554d41a">avl_find_lessequal</a> (const struct <a class="el" href="structavl__tree.html">avl_tree</a> *tree, const void *key)</td></tr>
<tr class="separator:aaa898c124264452198484c6d9554d41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2ec23650dde6aeb4d40ff6d9be2750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#ade2ec23650dde6aeb4d40ff6d9be2750">avl_insert</a> (struct <a class="el" href="structavl__tree.html">avl_tree</a> *, struct <a class="el" href="structavl__node.html">avl_node</a> *)</td></tr>
<tr class="separator:ade2ec23650dde6aeb4d40ff6d9be2750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c96765ca5857fc9f4272e494633e695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="avl_8h.html#a5c96765ca5857fc9f4272e494633e695">avl_remove</a> (struct <a class="el" href="structavl__tree.html">avl_tree</a> *, struct <a class="el" href="structavl__node.html">avl_node</a> *)</td></tr>
<tr class="separator:a5c96765ca5857fc9f4272e494633e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a65bfca92c030dd0ea5548f23de5fc07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bfca92c030dd0ea5548f23de5fc07e">&#9670;&nbsp;</a></span>avl_find_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_find_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_element&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#adbe2b7a707fb28492e3bf3530e907007">avl_find</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to key </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node element (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_element</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to tree element with the specified key, NULL if no element was found </dd></dl>

</div>
</div>
<a id="aabd583d925c5b1aa89caf22ed6148cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd583d925c5b1aa89caf22ed6148cf2">&#9670;&nbsp;</a></span>avl_find_ge_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_find_ge_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_element&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#a006b2043dafbfa776319ab77d8437989">avl_find_greaterequal</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to specified key </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node element (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_element</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct return pointer to first tree element with greater or equal key than specified key, NULL if no element was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad192b6c3845ad3a505b7bcb0d63dfeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad192b6c3845ad3a505b7bcb0d63dfeec">&#9670;&nbsp;</a></span>avl_find_le_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_find_le_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_element&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#a42a2090bd0f91336438b1b691143c950">container_of_if_notnull</a>(<a class="el" href="avl_8h.html#aaa898c124264452198484c6d9554d41a">avl_find_lessequal</a>(tree, key), <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_element)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to specified key </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node element (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_element</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct return pointer to last tree element with less or equal key than specified key, NULL if no element was found </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4277656aa8eae4fd79338987cfd26c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4277656aa8eae4fd79338987cfd26c97">&#9670;&nbsp;</a></span>avl_first_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_first_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((tree)-&gt;list_head.next, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must not be called for an empty tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node element (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element of the <a class="el" href="structavl__tree.html">avl_tree</a> (automatically converted to type 'element') </dd></dl>

</div>
</div>
<a id="aa1e4b75df996ec04ebdcddf6c936e97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e4b75df996ec04ebdcddf6c936e97d">&#9670;&nbsp;</a></span>avl_first_element_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_first_element_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(avl_is_empty(tree) ? NULL : <a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node element (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the first element of the <a class="el" href="structavl__tree.html">avl_tree</a> (automatically converted to type 'element'), NULL if tree is empty </dd></dl>

</div>
</div>
<a id="a78fce1e55fe672174caa3053a460ae56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fce1e55fe672174caa3053a460ae56">&#9670;&nbsp;</a></span>avl_for_each_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(                                                                                               \</div><div class="line">    <a class="code" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), <a class="code" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</div><div class="ttc" id="avl_8h_html_a03d15c4acb3bebd05c7f55835f761a02"><div class="ttname"><a href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a></div><div class="ttdeci">#define avl_for_element_range(first, last, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:351</div></div>
<div class="ttc" id="avl_8h_html_a4277656aa8eae4fd79338987cfd26c97"><div class="ttname"><a href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a></div><div class="ttdeci">#define avl_first_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:244</div></div>
<div class="ttc" id="avl_8h_html_a99a99bff7b106865d925fdc7461cdaad"><div class="ttname"><a href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a></div><div class="ttdeci">#define avl_last_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:271</div></div>
</div><!-- fragment --><p>Loop over all elements of an <a class="el" href="structavl__tree.html">avl_tree</a>, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the tree during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a708d9a638840e5762c4fffad19749d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708d9a638840e5762c4fffad19749d40">&#9670;&nbsp;</a></span>avl_for_each_element_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_element_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(                                                                                       \</div><div class="line">    <a class="code" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), <a class="code" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</div><div class="ttc" id="avl_8h_html_a4277656aa8eae4fd79338987cfd26c97"><div class="ttname"><a href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a></div><div class="ttdeci">#define avl_first_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:244</div></div>
<div class="ttc" id="avl_8h_html_ab79d2dca3164c0d9d147290f81cc0a1e"><div class="ttname"><a href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a></div><div class="ttdeci">#define avl_for_element_range_reverse(first, last, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:367</div></div>
<div class="ttc" id="avl_8h_html_a99a99bff7b106865d925fdc7461cdaad"><div class="ttname"><a href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a></div><div class="ttdeci">#define avl_last_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:271</div></div>
</div><!-- fragment --><p>Loop over all elements of an <a class="el" href="structavl__tree.html">avl_tree</a> backwards, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the tree during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8268f3218ef99abb26a7e5fe131ff7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8268f3218ef99abb26a7e5fe131ff7b5">&#9670;&nbsp;</a></span>avl_for_each_element_reverse_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_element_reverse_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="avl_8h.html#a753153e0b7e41586afc8bdc5dae9638a">avl_for_element_range_reverse_safe</a>(<a class="code" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member),                                    \</div><div class="line">    <a class="code" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member, ptr)</div><div class="ttc" id="avl_8h_html_a753153e0b7e41586afc8bdc5dae9638a"><div class="ttname"><a href="avl_8h.html#a753153e0b7e41586afc8bdc5dae9638a">avl_for_element_range_reverse_safe</a></div><div class="ttdeci">#define avl_for_element_range_reverse_safe(first_element, last_element, element, node_member, ptr)</div><div class="ttdef"><b>Definition:</b> avl.h:516</div></div>
<div class="ttc" id="avl_8h_html_a4277656aa8eae4fd79338987cfd26c97"><div class="ttname"><a href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a></div><div class="ttdeci">#define avl_first_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:244</div></div>
<div class="ttc" id="avl_8h_html_a99a99bff7b106865d925fdc7461cdaad"><div class="ttname"><a href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a></div><div class="ttdeci">#define avl_last_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:271</div></div>
</div><!-- fragment --><p>Loop over all elements of an <a class="el" href="structavl__tree.html">avl_tree</a> backwards, used similar to a for() command. This loop can be used if the current element might be removed from the tree during the loop. Other elements should not be removed during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the tree during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to a tree element which is used to store the next node during the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab23455256f763fb1e8034c6d9537a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23455256f763fb1e8034c6d9537a0ed">&#9670;&nbsp;</a></span>avl_for_each_element_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_element_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="avl_8h.html#a947645c2b3a446f3a3fe51b5d3a5ae9d">avl_for_element_range_safe</a>(<a class="code" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member),                                            \</div><div class="line">    <a class="code" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member, ptr)</div><div class="ttc" id="avl_8h_html_a947645c2b3a446f3a3fe51b5d3a5ae9d"><div class="ttname"><a href="avl_8h.html#a947645c2b3a446f3a3fe51b5d3a5ae9d">avl_for_element_range_safe</a></div><div class="ttdeci">#define avl_for_element_range_safe(first_element, last_element, element, node_member, ptr)</div><div class="ttdef"><b>Definition:</b> avl.h:498</div></div>
<div class="ttc" id="avl_8h_html_a4277656aa8eae4fd79338987cfd26c97"><div class="ttname"><a href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a></div><div class="ttdeci">#define avl_first_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:244</div></div>
<div class="ttc" id="avl_8h_html_a99a99bff7b106865d925fdc7461cdaad"><div class="ttname"><a href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a></div><div class="ttdeci">#define avl_last_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:271</div></div>
</div><!-- fragment --><p>Loop over all elements of an <a class="el" href="structavl__tree.html">avl_tree</a>, used similar to a for() command. This loop can be used if the current element might be removed from the tree during the loop. Other elements should not be removed during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the tree during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to a tree element which is used to store the next node during the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af13b5a4ff4e153f6c9e6d2bb5a791ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af13b5a4ff4e153f6c9e6d2bb5a791ef0">&#9670;&nbsp;</a></span>avl_for_each_elements_with_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_elements_with_key</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (start = element = <a class="code" href="avl_8h.html#a65bfca92c030dd0ea5548f23de5fc07e">avl_find_element</a>(tree, key, element, node_member);                                            \</div><div class="line">       element != NULL &amp;&amp; &amp;element-&gt;node_member.list != &amp;(tree)-&gt;list_head &amp;&amp;                                          \</div><div class="line">       (element == start || element-&gt;node_member.follower);                                                            \</div><div class="line">       element = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member))</div><div class="ttc" id="avl_8h_html_a65bfca92c030dd0ea5548f23de5fc07e"><div class="ttname"><a href="avl_8h.html#a65bfca92c030dd0ea5548f23de5fc07e">avl_find_element</a></div><div class="ttdeci">#define avl_find_element(tree, key, element, node_element)</div><div class="ttdef"><b>Definition:</b> avl.h:204</div></div>
<div class="ttc" id="avl_8h_html_a44808c5fc055437c429a05a9b0a06c64"><div class="ttname"><a href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a></div><div class="ttdeci">#define avl_next_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:297</div></div>
</div><!-- fragment --><p>Loop over a block of elements of a tree with a certain key, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
    <tr><td class="paramname">start</td><td>helper pointer to remember start of iteration </td></tr>
    <tr><td class="paramname">key</td><td>pointer to key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a5bd4e29fca7922b4d0a48bca7f6c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5bd4e29fca7922b4d0a48bca7f6c1e">&#9670;&nbsp;</a></span>avl_for_each_elements_with_key_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_each_elements_with_key_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">iterator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">key&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (start = element = <a class="code" href="avl_8h.html#a65bfca92c030dd0ea5548f23de5fc07e">avl_find_element</a>(tree, key, element, node_member),                                            \</div><div class="line">       iterator = <a class="code" href="avl_8h.html#ac9359a8fcb7171306d829d2ef0b9ce87">avl_next_element_safe</a>(tree, element, node_member);                                                              \</div><div class="line">       element != NULL &amp;&amp; &amp;element-&gt;node_member.list != &amp;(tree)-&gt;list_head &amp;&amp;                                          \</div><div class="line">       (element == start || element-&gt;node_member.follower);                                                            \</div><div class="line">       element = iterator, iterator = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(iterator, node_member))</div><div class="ttc" id="avl_8h_html_a65bfca92c030dd0ea5548f23de5fc07e"><div class="ttname"><a href="avl_8h.html#a65bfca92c030dd0ea5548f23de5fc07e">avl_find_element</a></div><div class="ttdeci">#define avl_find_element(tree, key, element, node_element)</div><div class="ttdef"><b>Definition:</b> avl.h:204</div></div>
<div class="ttc" id="avl_8h_html_a44808c5fc055437c429a05a9b0a06c64"><div class="ttname"><a href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a></div><div class="ttdeci">#define avl_next_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:297</div></div>
<div class="ttc" id="avl_8h_html_ac9359a8fcb7171306d829d2ef0b9ce87"><div class="ttname"><a href="avl_8h.html#ac9359a8fcb7171306d829d2ef0b9ce87">avl_next_element_safe</a></div><div class="ttdeci">#define avl_next_element_safe(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:310</div></div>
</div><!-- fragment --><p>Loop over a block of elements of a tree with a certain key, used similar to a for() command. This loop can be used if the current element might be removed from the tree during the loop. Other elements should not be removed during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
    <tr><td class="paramname">start</td><td>helper pointer to remember start of iteration </td></tr>
    <tr><td class="paramname">iterator</td><td>helper pointer to safe loop from element removal. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03d15c4acb3bebd05c7f55835f761a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d15c4acb3bebd05c7f55835f761a02">&#9670;&nbsp;</a></span>avl_for_element_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_range</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (element = (first); element-&gt;node_member.list.prev != &amp;(last)-&gt;node_member.list;                                 \</div><div class="line">       element = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member))</div><div class="ttc" id="avl_8h_html_a44808c5fc055437c429a05a9b0a06c64"><div class="ttname"><a href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a></div><div class="ttdeci">#define avl_next_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:297</div></div>
</div><!-- fragment --><p>Loop over a block of elements of a tree, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to first element of loop </td></tr>
    <tr><td class="paramname">last</td><td>pointer to last element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab79d2dca3164c0d9d147290f81cc0a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79d2dca3164c0d9d147290f81cc0a1e">&#9670;&nbsp;</a></span>avl_for_element_range_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_range_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (element = (last); element-&gt;node_member.list.next != &amp;(first)-&gt;node_member.list;                                 \</div><div class="line">       element = <a class="code" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(element, node_member))</div><div class="ttc" id="avl_8h_html_a026fe6e9f4d8435a20d49c98e05296ee"><div class="ttname"><a href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a></div><div class="ttdeci">#define avl_prev_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:323</div></div>
</div><!-- fragment --><p>Loop over a block of elements of a tree backwards, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>pointer to first element of loop </td></tr>
    <tr><td class="paramname">last</td><td>pointer to last element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753153e0b7e41586afc8bdc5dae9638a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753153e0b7e41586afc8bdc5dae9638a">&#9670;&nbsp;</a></span>avl_for_element_range_reverse_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_range_reverse_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first_element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last_element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (element = (last_element), ptr = <a class="code" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(element, node_member);                                         \</div><div class="line">       element-&gt;node_member.list.next != &amp;(first_element)-&gt;node_member.list;                                           \</div><div class="line">       element = ptr, ptr = <a class="code" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(ptr, node_member))</div><div class="ttc" id="avl_8h_html_a026fe6e9f4d8435a20d49c98e05296ee"><div class="ttname"><a href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a></div><div class="ttdeci">#define avl_prev_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:323</div></div>
</div><!-- fragment --><p>Loop over a block of elements of a tree backwards, used similar to a for() command. This loop can be used if the current element might be removed from the tree during the loop. Other elements should not be removed during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_element</td><td>first element of range (will be last returned by the loop) </td></tr>
    <tr><td class="paramname">last_element</td><td>last element of range (will be first returned by the loop) </td></tr>
    <tr><td class="paramname">element</td><td>iterator pointer to node element struct </td></tr>
    <tr><td class="paramname">node_member</td><td>name of <a class="el" href="structavl__node.html">avl_node</a> within node element struct </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to node element struct which is used to store the previous node during the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a947645c2b3a446f3a3fe51b5d3a5ae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947645c2b3a446f3a3fe51b5d3a5ae9d">&#9670;&nbsp;</a></span>avl_for_element_range_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_range_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first_element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last_element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (element = (first_element), ptr = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member);                                        \</div><div class="line">       element-&gt;node_member.list.prev != &amp;(last_element)-&gt;node_member.list;                                            \</div><div class="line">       element = ptr, ptr = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(ptr, node_member))</div><div class="ttc" id="avl_8h_html_a44808c5fc055437c429a05a9b0a06c64"><div class="ttname"><a href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a></div><div class="ttdeci">#define avl_next_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:297</div></div>
</div><!-- fragment --><p>Loop over a block of nodes of a tree, used similar to a for() command. This loop can be used if the current element might be removed from the tree during the loop. Other elements should not be removed during the loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first_element</td><td>first element of loop </td></tr>
    <tr><td class="paramname">last_element</td><td>last element of loop </td></tr>
    <tr><td class="paramname">element</td><td>iterator pointer to tree element struct </td></tr>
    <tr><td class="paramname">node_member</td><td>name of <a class="el" href="structavl__node.html">avl_node</a> within tree element struct </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to tree element struct which is used to store the next node during the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae57e527be83dae1b21136e7ba479b8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57e527be83dae1b21136e7ba479b8ce">&#9670;&nbsp;</a></span>avl_for_element_to_last</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_to_last</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(first, <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over a block of elements of a tree, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop. The loop runs from the element 'first' to the end of the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">first</td><td>pointer to first element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1917526ba24d06dc9bcc54979dc03d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1917526ba24d06dc9bcc54979dc03d9c">&#9670;&nbsp;</a></span>avl_for_element_to_last_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_element_to_last_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">first, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(first, <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member), element, node_member)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over a block of elements of a tree backwards, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop. The loop runs from the element 'first' to the end of the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">first</td><td>pointer to first element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a159c839ce250ac3aaf7f7f1109c062d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159c839ce250ac3aaf7f7f1109c062d5">&#9670;&nbsp;</a></span>avl_for_first_to_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_first_to_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="avl_8h.html#a03d15c4acb3bebd05c7f55835f761a02">avl_for_element_range</a>(<a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), last, element, node_member)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over a block of elements of a tree, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop. The loop runs from the start of the tree to the element 'last'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">last</td><td>pointer to last element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e9b3eeac0e8ccf932b344c0fda83a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9b3eeac0e8ccf932b344c0fda83a56">&#9670;&nbsp;</a></span>avl_for_first_to_element_reverse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_for_first_to_element_reverse</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">last, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="avl_8h.html#ab79d2dca3164c0d9d147290f81cc0a1e">avl_for_element_range_reverse</a>(<a class="el" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), last, element, node_member)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over a block of elements of a tree backwards, used similar to a for() command. This loop should not be used if elements are removed from the tree during the loop. The loop runs from the start of the tree to the element 'last'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">last</td><td>pointer to last element of loop </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the list during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99a99bff7b106865d925fdc7461cdaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a99bff7b106865d925fdc7461cdaad">&#9670;&nbsp;</a></span>avl_last_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_last_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((tree)-&gt;list_head.prev, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must not be called for an empty tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node struct that contains the <a class="el" href="structavl__node.html">avl_node</a> (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the last element of the <a class="el" href="structavl__tree.html">avl_tree</a> (automatically converted to type 'element') </dd></dl>

</div>
</div>
<a id="aa3b7118685741f22a5cab57c8432eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b7118685741f22a5cab57c8432eec1">&#9670;&nbsp;</a></span>avl_last_element_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_last_element_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(avl_is_empty(tree) ? NULL : <a class="el" href="avl_8h.html#a99a99bff7b106865d925fdc7461cdaad">avl_last_element</a>(tree, element, node_member))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node struct that contains the <a class="el" href="structavl__node.html">avl_node</a> (don't need to be initialized) </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the last element of the <a class="el" href="structavl__tree.html">avl_tree</a> (automatically converted to type 'element'), NULL if tree is empty </dd></dl>

</div>
</div>
<a id="a44808c5fc055437c429a05a9b0a06c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44808c5fc055437c429a05a9b0a06c64">&#9670;&nbsp;</a></span>avl_next_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_next_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((&amp;(element)-&gt;node_member.list)-&gt;next, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must not be called for the last element of an avl tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>pointer to a node of the tree </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node after 'element' (automatically converted to type 'element') </dd></dl>

</div>
</div>
<a id="ac9359a8fcb7171306d829d2ef0b9ce87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9359a8fcb7171306d829d2ef0b9ce87">&#9670;&nbsp;</a></span>avl_next_element_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_next_element_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((element) == NULL || avl_is_last(tree, &amp;(element)-&gt;node_member) ? NULL : <a class="el" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node after 'element' (automatically converted to type 'element'), NULL if there is no element after 'element' or 'element' is NULL </dd></dl>

</div>
</div>
<a id="a026fe6e9f4d8435a20d49c98e05296ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026fe6e9f4d8435a20d49c98e05296ee">&#9670;&nbsp;</a></span>avl_prev_element</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_prev_element</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="container__of_8h.html#af8c317a42292b61c93aae91e59118a46">container_of</a>((&amp;(element)-&gt;node_member.list)-&gt;prev, <a class="el" href="container__of_8h.html#acef73c7073b2cf605fb2cb64c5fc4990">typeof</a>(*(element)), node_member.list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function must not be called for the first element of an avl tree</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>pointer to a node of the tree </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node before 'element' (automatically converted to type 'element') </dd></dl>

</div>
</div>
<a id="a41e01666c8f5bf8bd7b115ea69e96cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e01666c8f5bf8bd7b115ea69e96cdc">&#9670;&nbsp;</a></span>avl_prev_element_safe</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_prev_element_safe</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((element) == NULL || avl_is_first(tree, &amp;(element)-&gt;node_member) ? NULL : <a class="el" href="avl_8h.html#a026fe6e9f4d8435a20d49c98e05296ee">avl_prev_element</a>(element, node_member))</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the node before 'element' (automatically converted to type 'element'), NULL if there is no element before 'element' or 'element' is NULL </dd></dl>

</div>
</div>
<a id="af8b3ca3843e7a4bb3bc80858f53c2ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b3ca3843e7a4bb3bc80858f53c2ad5">&#9670;&nbsp;</a></span>avl_remove_all_elements</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define avl_remove_all_elements</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tree, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">element, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">node_member, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span> (element = <a class="code" href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a>(tree, element, node_member), ptr = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(element, node_member),          \</div><div class="line">      list_init_head(&amp;(tree)-&gt;list_head), (tree)-&gt;root = NULL;                                                         \</div><div class="line">       (tree)-&gt;count &gt; 0; element = ptr, ptr = <a class="code" href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a>(ptr, node_member), (tree)-&gt;count--)</div><div class="ttc" id="avl_8h_html_a4277656aa8eae4fd79338987cfd26c97"><div class="ttname"><a href="avl_8h.html#a4277656aa8eae4fd79338987cfd26c97">avl_first_element</a></div><div class="ttdeci">#define avl_first_element(tree, element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:244</div></div>
<div class="ttc" id="avl_8h_html_a44808c5fc055437c429a05a9b0a06c64"><div class="ttname"><a href="avl_8h.html#a44808c5fc055437c429a05a9b0a06c64">avl_next_element</a></div><div class="ttdeci">#define avl_next_element(element, node_member)</div><div class="ttdef"><b>Definition:</b> avl.h:297</div></div>
</div><!-- fragment --><p>A special loop that removes all elements of the tree and cleans up the tree root. The loop body is responsible to free the node elements of the tree.</p>
<p>This loop is faster than a normal one for clearing the tree because it does not rebalance the tree after each removal. Do NOT use a break command inside. You can free the memory of the elements within the loop. Do NOT call avl_delete() on the elements within the loop,</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">element</td><td>pointer to a node of the tree, this element will contain the current node of the tree during the loop </td></tr>
    <tr><td class="paramname">node_member</td><td>name of the <a class="el" href="structavl__node.html">avl_node</a> element inside the larger struct </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer to a tree element which is used to store the next node during the loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade9b574d813366c603812eb967213c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b574d813366c603812eb967213c75">&#9670;&nbsp;</a></span>AVL_STATIC_INIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVL_STATIC_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">avl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">avl_comp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dups&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                                                                    \</div><div class="line">    .list_head = { .next = &amp;avl.list_head, .prev = &amp;avl.list_head }, .root = NULL, .count = 0, .allow_dups = dups,     \</div><div class="line">    .comp = avl_comp                                                                                                   \</div><div class="line">  }</div></div><!-- fragment --><p>Static initializer for AVL tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">avl</td><td><a class="el" href="structavl__tree.html">avl_tree</a> variable (not pointer!) </td></tr>
    <tr><td class="paramname">avl_comp</td><td>comparator to be used </td></tr>
    <tr><td class="paramname">dups</td><td>true if duplicates are allowed, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adbe2b7a707fb28492e3bf3530e907007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe2b7a707fb28492e3bf3530e907007">&#9670;&nbsp;</a></span>avl_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a>* avl_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a node in an avl-tree with a certain key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to avl-node with key, NULL if no node with this key exists. </dd></dl>

</div>
</div>
<a id="a006b2043dafbfa776319ab77d8437989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006b2043dafbfa776319ab77d8437989">&#9670;&nbsp;</a></span>avl_find_greaterequal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a>* avl_find_greaterequal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the first node in an avl-tree with a key greater or equal than the specified key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to specified key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to avl-node, NULL if no node with key greater or equal specified key exists. </dd></dl>

</div>
</div>
<a id="aaa898c124264452198484c6d9554d41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa898c124264452198484c6d9554d41a">&#9670;&nbsp;</a></span>avl_find_lessequal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> struct <a class="el" href="structavl__node.html">avl_node</a>* avl_find_lessequal </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the last node in an avl-tree with a key less or equal than the specified key </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">key</td><td>pointer to specified key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to avl-node, NULL if no node with key less or equal specified key exists. </dd></dl>

</div>
</div>
<a id="a34c5f9b73909d1b4abadb947a0f898dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c5f9b73909d1b4abadb947a0f898dd">&#9670;&nbsp;</a></span>avl_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void avl_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *k1, const void *k2)&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_dups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a new <a class="el" href="structavl__tree.html">avl_tree</a> struct </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to avl-tree </td></tr>
    <tr><td class="paramname">comp</td><td>pointer to comparator for the tree </td></tr>
    <tr><td class="paramname">allow_dups</td><td>true if the tree allows multiple elements with the same </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="avl_8h_a34c5f9b73909d1b4abadb947a0f898dd_icgraph.png" border="0" usemap="#avl_8h_a34c5f9b73909d1b4abadb947a0f898dd_icgraph" alt=""/></div>
<map name="avl_8h_a34c5f9b73909d1b4abadb947a0f898dd_icgraph" id="avl_8h_a34c5f9b73909d1b4abadb947a0f898dd_icgraph">
<area shape="rect" id="node2" href="oonf__duplicate__set_8h.html#abda162a4f537b9186800d01e97aaf80f" title="oonf_duplicate_set_add" alt="" coords="118,5,277,32"/>
<area shape="rect" id="node3" href="dlep__extension_8h.html#a16b0ad277de4ab45d059b5ae1995ad60" title="dlep_extension_init" alt="" coords="131,56,264,83"/>
<area shape="rect" id="node6" href="cfg_8h.html#a0edc23e6767c9ab0cef842e1f7841dc1" title="cfg_add" alt="" coords="163,107,231,133"/>
<area shape="rect" id="node8" href="cfg__db_8h.html#a0ce18be4f8b7234b7905dc3855b85589" title="cfg_db_add" alt="" coords="153,157,242,184"/>
<area shape="rect" id="node10" href="neighbor-graph_8h.html#abf3949aafc21bc6f2b040114227375fa" title="mpr_init_neighbor_graph" alt="" coords="116,208,279,235"/>
<area shape="rect" id="node12" href="nhdp__db_8h.html#a41f9c04c50a9f8253dfd5c14700d03a9" title="nhdp_db_init" alt="" coords="150,259,245,285"/>
<area shape="rect" id="node13" href="nhdp__db_8h.html#ad341ab7a5dedd83fd15e0e0af0244acf" title="nhdp_db_neighbor_add" alt="" coords="120,309,275,336"/>
<area shape="rect" id="node14" href="nhdp__interfaces_8h.html#a4a6495a47674c0573e0fed8b7d720955" title="nhdp_interfaces_init" alt="" coords="128,360,267,387"/>
<area shape="rect" id="node15" href="olsrv2__lan_8h.html#a3d9bd32dd3a37dcbbc4694dc72249f1c" title="olsrv2_lan_init" alt="" coords="145,411,250,437"/>
<area shape="rect" id="node16" href="olsrv2__originator_8h.html#a82d9425a87752608fe9131faeb9d8d87" title="olsrv2_originator_init" alt="" coords="127,461,268,488"/>
<area shape="rect" id="node17" href="olsrv2__tc_8h.html#acb8b12b171d9a93bad613df611d4b18e" title="olsrv2_tc_init" alt="" coords="148,512,247,539"/>
<area shape="rect" id="node4" href="dlep__radio__interface_8h.html#a1dec57cc2ee5fe9614fc19fbd4400460" title="dlep_radio_interface_init" alt="" coords="329,5,491,32"/>
<area shape="rect" id="node5" href="dlep__router__interface_8h.html#a880e1ad49aa5691c8678f95ff5ab9621" title="dlep_router_interface_init" alt="" coords="327,56,493,83"/>
<area shape="rect" id="node7" href="test__config__cmd_8c.html#a5d6593faf282c1f0cec0d54c63dba874" title="main" alt="" coords="385,107,435,133"/>
<area shape="rect" id="node9" href="cfg__schema_8h.html#a914b6e7c64862ab04c421a9660701cbb" title="cfg_schema_handle_db\l_startup_changes" alt="" coords="331,158,489,199"/>
<area shape="rect" id="node11" href="neighbor-graph-flooding_8h.html#a4f72c5dd647ff97fe54b8c16ba5b1dfe" title="mpr_calculate_neighbor\l_graph_flooding" alt="" coords="331,223,489,265"/>
</map>
</div>

</div>
</div>
<a id="ade2ec23650dde6aeb4d40ff6d9be2750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2ec23650dde6aeb4d40ff6d9be2750">&#9670;&nbsp;</a></span>avl_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> int avl_insert </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structavl__node.html">avl_node</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an <a class="el" href="structavl__node.html">avl_node</a> into a tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>avl tree </td></tr>
    <tr><td class="paramname">new</td><td>node to be inserted into the tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if node was inserted successfully, -1 if it was not inserted because of a key collision </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="avl_8h_ade2ec23650dde6aeb4d40ff6d9be2750_icgraph.png" border="0" usemap="#avl_8h_ade2ec23650dde6aeb4d40ff6d9be2750_icgraph" alt=""/></div>
<map name="avl_8h_ade2ec23650dde6aeb4d40ff6d9be2750_icgraph" id="avl_8h_ade2ec23650dde6aeb4d40ff6d9be2750_icgraph">
<area shape="rect" id="node2" href="oonf__http_8h.html#aa55c0717dd6eda08ffd4dbded924722e" title="oonf_http_add" alt="" coords="179,5,283,32"/>
<area shape="rect" id="node3" href="oonf__layer2_8h.html#a411ecb3fc368b20516570f6ed5fa19fc" title="oonf_layer2_origin_add" alt="" coords="154,56,309,83"/>
<area shape="rect" id="node5" href="oonf__telnet_8h.html#af9a36d923f9d0df135a13f3ea5f78fa1" title="oonf_telnet_add" alt="" coords="174,107,289,133"/>
<area shape="rect" id="node6" href="rfc7182__provider_8c.html#a7d3878125b9ab918dd9d943122e80e41" title="rfc7182_add_hash" alt="" coords="167,157,295,184"/>
<area shape="rect" id="node7" href="cfg__io_8h.html#ac15e8bf1fca7b05ec9f19958a8f3129c" title="cfg_io_add" alt="" coords="189,208,274,235"/>
<area shape="rect" id="node8" href="neighbor-graph_8h.html#ab6a7ce3b44227be0bcc567dcbe90762b" title="mpr_add_n1_node_to_set" alt="" coords="146,259,317,285"/>
<area shape="rect" id="node9" href="neighbor-graph_8h.html#ae065d9a2eae7e59b32d8a64ae76ade85" title="mpr_add_addr_node_to_set" alt="" coords="140,309,323,336"/>
<area shape="rect" id="node10" href="nhdp__db_8h.html#aca7e1a9cc4d216c257a707c42323d210" title="nhdp_db_neighbor_join" alt="" coords="154,360,309,387"/>
<area shape="rect" id="node11" href="nhdp__db_8h.html#ab32cc6c21ef36a74eb7ec3d63d5eb477" title="nhdp_db_neighbor_addr_move" alt="" coords="132,411,331,437"/>
<area shape="rect" id="node12" href="nhdp__db_8h.html#a15f85fd40f3797f360bc3dac6f927702" title="nhdp_db_link_addr_add" alt="" coords="152,461,311,488"/>
<area shape="rect" id="node13" href="nhdp__db_8h.html#a1e72319b08e2283451cfbb7988d2f085" title="nhdp_db_link_addr_move" alt="" coords="147,512,316,539"/>
<area shape="rect" id="node14" href="nhdp__domain_8h.html#ac3f0d65c6859799238339f370a77c3ca" title="nhdp_domain_mpr_add" alt="" coords="153,563,309,589"/>
<area shape="rect" id="node4" href="dlep__router__interface_8h.html#a880e1ad49aa5691c8678f95ff5ab9621" title="dlep_router_interface_init" alt="" coords="379,56,545,83"/>
</map>
</div>

</div>
</div>
<a id="a5c96765ca5857fc9f4272e494633e695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c96765ca5857fc9f4272e494633e695">&#9670;&nbsp;</a></span>avl_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="oonf_8h.html#a3472d8cdbb788d5f1815b3522595bc49">EXPORT</a> void avl_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structavl__tree.html">avl_tree</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structavl__node.html">avl_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a node from an avl tree </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>pointer to tree </td></tr>
    <tr><td class="paramname">node</td><td>pointer to node </td></tr>
  </table>
  </dd>
</dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="avl_8h_a5c96765ca5857fc9f4272e494633e695_icgraph.png" border="0" usemap="#avl_8h_a5c96765ca5857fc9f4272e494633e695_icgraph" alt=""/></div>
<map name="avl_8h_a5c96765ca5857fc9f4272e494633e695_icgraph" id="avl_8h_a5c96765ca5857fc9f4272e494633e695_icgraph">
<area shape="rect" id="node2" href="oonf__class_8h.html#a07f7d42c5611d70db492b4fce19dd6d3" title="oonf_class_remove" alt="" coords="175,101,309,127"/>
<area shape="rect" id="node8" href="oonf__http_8h.html#a9aa5b325f67a26b0014338bbb89079ff" title="oonf_http_remove" alt="" coords="179,151,305,178"/>
<area shape="rect" id="node9" href="oonf__layer2_8h.html#a0c584677e2df4326bbc7cf51a3a733e0" title="oonf_layer2_net_remove_ip" alt="" coords="151,202,333,229"/>
<area shape="rect" id="node10" href="oonf__layer2_8h.html#aed3e335cc62af5dc0a2227b5b7cba2d0" title="oonf_layer2_neigh_remove_ip" alt="" coords="145,253,339,279"/>
<area shape="rect" id="node11" href="oonf__rfc5444_8h.html#a785959cd4238edb36b80d39ffae5d1fb" title="oonf_rfc5444_remove\l_protocol" alt="" coords="169,304,315,345"/>
<area shape="rect" id="node12" href="oonf__telnet_8h.html#ab3d50471c0882d68be51214584255292" title="oonf_telnet_remove" alt="" coords="174,370,310,397"/>
<area shape="rect" id="node13" href="oonf__timer_8h.html#a25707fd3740159263ef1795e0323ddcb" title="oonf_timer_start_ext" alt="" coords="171,421,313,447"/>
<area shape="rect" id="node15" href="oonf__timer_8h.html#a973c46eacc0be7b8ea02a1f1e6c9d5f0" title="oonf_timer_stop" alt="" coords="185,522,299,549"/>
<area shape="rect" id="node16" href="dlep__session_8h.html#a08f5590fc65835d6232f1e3971e011ef" title="dlep_session_remove\l_local_neighbor" alt="" coords="395,424,543,465"/>
<area shape="rect" id="node20" href="olsrv2__tc_8h.html#a531ed4edc806a4da3aa7b89769eac27d" title="olsrv2_tc_node_remove" alt="" coords="389,657,549,683"/>
<area shape="rect" id="node21" href="rfc5444__signature_8c.html#a62c13cc913a7b1a6b505077737e1783d" title="rfc5444_sig_remove" alt="" coords="173,690,311,717"/>
<area shape="rect" id="node22" href="rfc7182__provider_8c.html#a151f5d43eb8a1a06876fe8655466e6c5" title="rfc7182_remove_hash" alt="" coords="167,741,317,767"/>
<area shape="rect" id="node23" href="rfc7182__provider_8c.html#abfa6b15b905811c9f666db93fa9f458d" title="rfc7182_remove_crypt" alt="" coords="167,791,317,818"/>
<area shape="rect" id="node24" href="dlep__interface_8h.html#abc269d9df0e370d48523cbc3f8e10237" title="dlep_if_remove" alt="" coords="187,842,297,869"/>
<area shape="rect" id="node25" href="neighbor-graph_8h.html#adac8c1e2e526fc08c02cab0d33318285" title="mpr_clear_addr_set" alt="" coords="174,893,310,919"/>
<area shape="rect" id="node27" href="neighbor-graph_8h.html#a2bf6c23dbe35c821da7621897ecd468e" title="mpr_clear_n1_set" alt="" coords="179,943,305,970"/>
<area shape="rect" id="node28" href="nhdp__db_8h.html#aca7e1a9cc4d216c257a707c42323d210" title="nhdp_db_neighbor_join" alt="" coords="165,994,319,1021"/>
<area shape="rect" id="node29" href="nhdp__db_8h.html#a250c9b80b493fd7b76bdbf6c82174caa" title="nhdp_db_neighbor_addr\l_remove" alt="" coords="163,1045,321,1087"/>
<area shape="rect" id="node30" href="nhdp__db_8h.html#ab32cc6c21ef36a74eb7ec3d63d5eb477" title="nhdp_db_neighbor_addr_move" alt="" coords="143,1111,341,1138"/>
<area shape="rect" id="node31" href="nhdp__db_8h.html#a1e72319b08e2283451cfbb7988d2f085" title="nhdp_db_link_addr_move" alt="" coords="157,1162,327,1189"/>
<area shape="rect" id="node32" href="nhdp__db_8h.html#ac7ea854629a5ff77fdd1202602a68e3a" title="nhdp_db_link_2hop_remove" alt="" coords="151,1213,333,1239"/>
<area shape="rect" id="node33" href="olsrv2__tc_8h.html#a394fb2ad0f9051cf90e9e260c624be4b" title="olsrv2_tc_endpoint\l_remove" alt="" coords="177,624,307,665"/>
<area shape="rect" id="node3" href="ip_8h.html#a3ef1ebc51d17b5d4a79f81b93b6b84a1" title="dlep_base_ip_cleanup" alt="" coords="394,101,545,127"/>
<area shape="rect" id="node4" href="dlep__router__interface_8h.html#a406962c877cb18a3380b30556d1c59a9" title="dlep_router_interface\l_cleanup" alt="" coords="597,152,740,193"/>
<area shape="rect" id="node5" href="dlep__radio__interface_8h.html#afda3b99ed685caecfb3d0b864037807f" title="dlep_radio_interface\l_cleanup" alt="" coords="599,5,738,47"/>
<area shape="rect" id="node6" href="dlep__radio__session_8h.html#a666eb57079d0959ab0fa98998bdea5a6" title="dlep_radio_session\l_cleanup" alt="" coords="403,35,536,76"/>
<area shape="rect" id="node7" href="dlep__router__session_8h.html#ae1aa9589137cd322c14f3bfcafe5d59d" title="dlep_router_session\l_cleanup" alt="" coords="400,152,539,193"/>
<area shape="rect" id="node14" href="oonf__timer_8h.html#a7a6172766755292ecd0c8b2afaadaaa5" title="oonf_timer_set_ext" alt="" coords="403,373,536,399"/>
<area shape="rect" id="node17" href="proto_8h.html#a78b9598ba648637b54d80b9846ebdbbb" title="dlep_base_proto_stop\l_timers" alt="" coords="395,489,544,531"/>
<area shape="rect" id="node18" href="nhdp__db_8h.html#a820b9d7a6274fff55d0db246e9e66271" title="nhdp_db_link_remove" alt="" coords="395,555,543,582"/>
<area shape="rect" id="node19" href="olsrv2__routing_8h.html#a67cda037c6ea0677462e8e971f812ec8" title="olsrv2_routing_cleanup" alt="" coords="392,606,547,633"/>
<area shape="rect" id="node26" href="neighbor-graph_8h.html#a17989220b095a0b43b1906fe94a0edc8" title="mpr_clear_neighbor\l_graph" alt="" coords="402,911,537,952"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
